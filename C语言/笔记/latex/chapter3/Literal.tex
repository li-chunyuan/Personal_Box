\section{从字面量（Literal）到数据类型}

\subsection{何为魔法数字？}%有代码
首先来解释一下什么是字面量。在C语言中，字面量指的是
直接出现在源代码中的常量值，无需标识符即可使用。说得
大白话一点，就是代码中一个又一个数据。如\autoref{lst:literal}
所示，代码中出现的一个又一个常量数字如\texttt{42}、\texttt{'A'}、
\texttt{3.1416}、\texttt{Hi}
就是字面量。


\begin{lstlisting}[language=C,caption={C 语言中字面量的示例},label={lst:literal}]
#include <stdio.h>

int main(void) {
    int x = 42;          // 42 是整型字面量
    char c = 'A';        // 'A' 是字符字面量
    double pi = 3.1416;  // 3.1416 是浮点字面量
    printf("%s\n", "Hi"); // "Hi" 是字符串字面量
    return 0;
}
\end{lstlisting}


在我们日常生活中，我们每天都会接触大量的
数据，比如购物、计数。但我们从来不会纠结于
数据类型或是字面量这些乱七八糟的东西。这是因为
在日常生活中，我们普遍使用\textbf{十进制}，
所以对于我们彼此交流的时候，从来都不会纠结于进制、类型问题。


但在计算机中可不是这样，首先在计算机底部存储数字
使用二进制，而其他八进制、十六进制等进制也是常见的表示方式，
再加上由于计算机存储数据的方式不同又诞生了浮点数
、整型数、字符。所以当你冷不丁地给计算机抛出一个数字42时,计算机
并不能理解这个数字到底是什么进制、类型，如\autoref{lst:42}
所示，计算机并不能理解这是十进制的42，还是
八进制的\texttt{34}，还是十六进制的\texttt{68}。它更无法理解这到底是
\texttt{int}、\texttt{double}还是\texttt{float}。

计算机此时只能按照默认处理规则进行处理，默认情况下这个\texttt{42}
将被理解为十进制、\texttt{int}类型的数据。但如果你的本意并不是这样，
而是想表达其他进制或类型的数据，那么计算机就会误解你的意思。那么在
工程场景下，往往就会引发严重的错误。


\begin{lstlisting}[language=C,caption={魔法数字实例},label={lst:42}]
                                      42
\end{lstlisting}

计算机遇到这种情况时，
它是无法理解的，因为它不知道这个数字到底是什么进制、类型。
这就好像一个麻瓜突然看到一个魔法师念咒语一样（来自哈利波特），
它根本无法理解魔法师到底在说什么。对于这种情况，我们形象地
称为魔法数字（Magic Number）。



\subsection{定义与概念}
在 \textbf{C 语言标准}（如 ISO/IEC 9899:2018, C17）中，``字面量''（\textit{literal} 或 \textit{literal constant}）是一个正式存在的术语。  
它指的是 \textbf{直接出现在源代码中的常量值}，无需标识符即可使用。

\begin{center}
\begin{tabular}{lll}
\hline
\textbf{字面量类型} & \textbf{示例} & \textbf{说明} \\
\hline
整型字面量 (integer literal) & \verb|123|, \verb|0x7B|, \verb|010| & 十进制、十六进制、八进制整数 \\
浮点型字面量 (floating-point literal) & \verb|3.14|, \verb|1e-3| & 双精度浮点数 \\
字符字面量 (character constant) & \verb|'A'|, \verb|'\n'| & 单个字符，本质为 \verb|int| 类型 \\
字符串字面量 (string literal) & \verb|"Hello"| & 以 \verb|\0| 结尾的 \verb|char| 数组 \\
\hline
\end{tabular}
\end{center}

\subsection{字面量的具体区分方式}

C 语言里面通过“前缀（\texttt{prefix}）”和“后缀（\texttt{suffix}）”来对
字面量（\texttt{literal}）进行类型和进制的区分。
本节总结了 C 语言中通过前缀 \texttt{（Prefix）} 与
后缀 \texttt{（Suffix）} 来区分字面量的进制与类型的方式。
内容适用于 C89/C99/C11/C23 标准。



\subsubsection{整数：通过前缀区分进制}

整数字面量可使用前缀（\texttt{prefix}）确定进制，如 \autoref{tab:int-prefix} 所示。

\begin{table}[h!]
\centering
\caption{整数前缀及其含义}\label{tab:int-prefix}
\begin{tabular}{c|c|c}
\hline
前缀 & 进制 & 示例 \\ \hline
(无前缀) & 十进制 & \verb|123| \\
\verb|0| & 八进制 & \verb|0123| （十进制 83）\\
\verb|0x| / \verb|0X| & 十六进制 & \verb|0x123| （十进制 291）\\
\verb|0b| / \verb|0B|（C23） & 二进制 & \verb|0b1010| （十进制 10）\\
\hline
\end{tabular}
\end{table}


注意：
\begin{itemize}
    \item 以 \texttt{0} 开头的整数默认按八进制解析（如 \texttt{0123} $\neq$ \texttt{123}）。
    所以在 C 语言中避免使用前导零，以免引起歧义。这算是一个非常经典的错误原因呢。
    \item  C89/C99/C11 没有二进制前缀， 直到 C23 才正式加入\texttt{0b}作为二进制前缀，
    有些编译器（如 GCC）较早支持。
    \item C 语言中只有十六进制浮点数可以带前缀，其他进制的浮点数一律不允许带前缀。
    （具体见后文）。
\end{itemize}


 
\subsubsection{整数：通过后缀区分类型}



整数字面量的类型可由后缀（Suffix）确定。表 \ref{tab:int-suffix} 汇总了常见后缀。

\begin{table}[h]
\centering
\caption{整数类型后缀}\label{tab:int-suffix}
\begin{tabular}{cccc}
\hline
后缀 & 类型 & 示例 & 中文含义 \\ \hline
(无后缀) & int & \verb|123| & 整型（默认类型） \\

\verb|u| / \verb|U| & unsigned int & \verb|123U| & 无符号整型 \\

\verb|l| / \verb|L| & long int & \verb|123L| & 长整型 \\

\verb|ul| / \verb|UL| & unsigned long & \verb|123UL|, \verb|123LU| & 无符号长整型 \\

\verb|ll| / \verb|LL| & long long int & \verb|123LL| & 长长整型 \\

组合使用 & unsigned long long 等 & \verb|123ULL|, \verb|123LLU| & 无符号长长整型 \\ \hline
\end{tabular}
\end{table}



如\autoref{lst:int-suffix}所示，不同的类型其实意味着\textbf{存储空间}和\textbf{取值范围}
的不同。
所以当你由于不同的应用场景需要表示不同范围的整数时，
可以使用相应的后缀来指定类型。如果这个范围不匹配，
编译器会报错或发出警告。


\begin{lstlisting}[language=C,caption={后缀示例},label={lst:int-suffix}]

123        // int (默认类型)             -2147483648 ～ 2147483647 (32位系统)
123U       // unsigned int              0 ～ 4294967295

123L       // long int                  -2147483648 ～ 2147483647 (32位系统)
123LU      // unsigned long int         0 ～ 4294967295 (32位系统)

123LL      // long long int         -9223372036854775808 ～ 9223372036854775807
123LLU     // unsigned long long int    0 ～ 18446744073709551615

  
//以上给出的数据范围基于常见的32位和64位系统，
//实际范围基于编译器、CPU 架构和操作系统选择的数据模型而异。

\end{lstlisting}

\vspace{1em}
\noindent\textbf{注意}

作为整数字面量后缀：llu 和 ull 完全等价，可以随便使用，没有任何问题。
但在 printf 格式字符串中：必须用 \%llu，不能用 \%ull。所以我推荐大家统一
记忆llu。

\newpage



\subsubsection{浮点数：无前缀（Prefix 不可用）}%有假标题

浮点数\textbf{不能使用前缀} 来表示进制，不能像整数那样写成八进制、二进制形式：

\begin{itemize}
    \item \verb|012.3| （非法，浮点不能为八进制）
    \item \verb|0b1.01| （非法，C 不支持二进制小数）
    \item \verb|0x3.14| （非法的普通十六进制形式）
\end{itemize}



因此：浮点字面量不允许使用任何前缀。但凡事总有例外，在C语言中，十六进制浮点数就能表示
，但其他进制的浮点数一律不允许带前缀。也就是说
\[\textbf{C语言中浮点数只能有两种存在方式，第一种是默认的十进制，第二种是十六进制。}\]

\noindent\textbf{使用前缀表示十六进制浮点常量（C99 及以后）}
\vspace{0.8em}


最开始，浮点字面量\textbf{不能}写成 \verb|012.3|（八进制）、\verb|0b1.01|（二进制）、
\verb|0x3.14|（十六进制）等形式。

但是，从 C99 标准开始，C 语言\textbf{新增}了一类字面量：
\emph{十六进制浮点常量}（hexadecimal floating constant）。  
这一类浮点常量是\textbf{允许}使用 \verb|0x| 或 \verb|0X| 前缀的，
只是语法与整数常量不同，因此很多教材在入门阶段会直接略去不讲。

\vspace{1em}

\noindent\textbf{(1)~十六进制浮点常量的一般形式}\par\vspace{0.5em}

\noindent{十六进制浮点常量的大致结构可以写成:}
\[
\begin{aligned}
  \underbrace{\mathtt{0x}\ \mbox{/}\ \mathtt{0X}}_{\mbox{十六进制前缀}}
  \quad
  \underbrace{\mbox{十六进制数字（可带小数点）}}_{\mbox{significand}}
  \quad
  \underbrace{\mathtt{p}\ \mbox{/}\ \mathtt{P} + \mbox{十进制指数}}_{\mbox{以 2 为底的指数}}
  \quad
  \underbrace{\mbox{浮点后缀 }(\mathtt{f},\mathtt{F},\mathtt{l},\mathtt{L})}_{\mbox{类型说明}}
\end{aligned}
  \]

更口语一点的记忆方式：  
\begin{center}
\verb|0x| \texttt{十六进制小数部分} \verb|p| \texttt{十进制整数指数} \texttt{[可选后缀]}
\end{center}

\noindent
其数值等价于：
\[
  \pm\,\mbox{(十六进制有效数字)} \times 2^{\mbox{指数}}
\]

\newpage

\noindent\textbf{(2)~若干合法示例}\par\vspace{0.5em}

\begin{table}[H]
\centering
\caption{十六进制浮点常量示例及其对应值}\label{tab:hex-float}
\begin{tabular}{ll}
\toprule
字面量 & 对应的十进制值（大致含义） \\
\midrule
\verb|0x1.2p3|       & $(1 + 2/16) \times 2^{3} = 1.125 \times 8 = 9.0$ \\
\verb|0x9A.8p-1|     & $(154 + 8/16) \times 2^{-1} = 154.5 / 2 = 77.25$ \\
\verb|0x1.921fb6p1f| & $\approx 3.1415927\quad(\texttt{float}，接近 \pi)$ \\
\bottomrule
\end{tabular}
\end{table}






下面用代码形式再演示一次（需要支持 C99 及以上标准的编译器，例如 \verb|gcc -std=c11|）：

\begin{lstlisting}[language=C,caption={十六进制浮点常量示例},label={code:hex-float}]
#include <stdio.h>

int main(void) {
    double b = 0x1.8p1;   // 3.0
    double c = 0x1.fp2;   // 7.75
    float  d = 0x.ap-3f;  // 0.078125f

    printf("b = %f\n", b);
    printf("c = %f\n", c);
    printf("d = %f\n", d);
    return 0;
}
\end{lstlisting}

\vspace{1em}
\noindent\textbf{(3)~为什么 \texttt{0x3.14} 仍然是“非法写法”？}\par\vspace{0.5em}


在上一小节我们给出例子：\verb|0x3.14| “非法的普通十六进制形式”。  
这个结论在 C99 之后\textbf{依然成立}，原因是：

\begin{itemize}
  \item 对整数常量来说，形如 \verb|0x3.14| 带小数点，本来就不是合法的“整数十六进制字面量”；
  \item 对十六进制浮点常量来说，\verb|0x3.14| 也\textbf{不完整}，因为缺少必须的 \verb|p| 或 \verb|P| 指数部分。
\end{itemize}

也就是说，\verb|0x3.14| 只是一个“十六进制有效数字”，\textbf{不是}完整的“十六进制浮点常量”。  
如果把它补写完整，例如：
\[
  \verb|0x3.14p0|,\quad
  \verb|0x3.14p+0|,\quad
  \verb|0x3.14p4|
\]
这些才是标准允许的、真正合法的十六进制浮点字面量。

\vspace{1em}
\noindent\textbf{(4)~~对“浮点数不能用前缀”说法的精确修正}\par\vspace{0.5em}


因此，可以更严谨地改写原结论：

\begin{itemize}

  \item \textbf{浮点常量}（如 \verb|3.14|、\verb|1e-3|）不能使用 \verb|0|、\verb|0x|、\verb|0b| 等进制前缀；
  \item 从 C99 起，C 语言单独引入了\textbf{十六进制浮点常量}，其写法\emph{必须}带有
        \verb|0x|/\verb|0X| 前缀，并以 \verb|p|/\verb|P| 引出二进制指数。
\end{itemize}

在入门阶段，为了避免一次性给出过多语法细节，很多教材会只讲“无前缀的十进制浮点常量”，
并用“浮点数不能用前缀”这样简化的说法帮助初学者形成直觉。  
而在更高阶段学习标准（C99 及以后）时，就需要把十六进制浮点常量这一部分补充进来。

\subsection{浮点数的后缀}%有代码，有表格

浮点字面量只能用后缀确定类型，如表 \ref{tab:float-suffix} 所示。

\begin{table}[h]
\centering
\caption{浮点数字面量类型与后缀}\label{tab:float-suffix}
\begin{tabular}{cccccc}
\hline
后缀 & 类型 & 示例 & 字节数（典型） & 精度（有效数字） & 中文含义 \\ \hline

(无后缀) & double & \verb|3.14| 
& 8 字节
& 约 15–16 位 
& 双精度浮点数(默认) \\

\verb|f| / \verb|F| & float & \verb|3.14f| 
& 4 字节
& 约 6–7 位 
& 单精度浮点数 \\

\verb|l| / \verb|L| & long double & \verb|3.14L| 
& 10–16 字节
& 约 18–33 位 
& 扩展精度浮点数 \\

\hline
\end{tabular}
\end{table}


示例：



\begin{lstlisting}[language=C,caption={浮点数后缀示例},label={code:float-suffix}]
#include <stdio.h>

int main(void) {
3.14f        // float
2.718L       // long double
1e-3         // double（默认类型）
}
\end{lstlisting}


\subsection{总结}

\begin{itemize}
    \item 整数字面量：\textbf{前缀区分进制，后缀区分类型}。
    \item 浮点字面量：\textbf{无前缀，只能用后缀区分类型}。
    \item C99 起提供十六进制浮点字面量（如 \verb|0x1.2p3|）。
\end{itemize}






























