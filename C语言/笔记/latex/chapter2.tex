\section{C语言的数据与运算}

\subsection{变量与常量}

\subsubsection{变量}

变量（Variable）是程序在运行过程中用于存储数据的命名空间。
每个变量在内存中都有一个存储单元，用于保存值，其内容可以在
程序执行过程中改变。你可以把它暂时理解为一个装满数据的容器或者
是一个可以住人的房间。例如：

\begin{lstlisting}[language=C,caption={变量声明示例},label={lst:variables}]
int a = 10;
float b = 3.14;
char c = 'A';
\end{lstlisting}
\vspace{1em}%空出一行距离（当前字体高度）

\subsubsection{常量}
在C语言程序设计中，常量（Constant）是指程序在
运行过程中，其值不可改变的量。合理地定义常量可以提升
代码的可读性和可维护性。
本文对比三种常用常量定义方式：\texttt{\#define} 宏常量、
\texttt{const} 常量
与 \texttt{enum} 枚举常量，并给出实践建议。

\newpage

\begin{enumerate}[label={(\arabic*)}]
\item 符号常量\texttt{\#define} 

\texttt{\#define} 在预处理阶段进行\emph{文本替换}，指定用一个
符号名称来代替一个常量。它不参与
类型检查，也不分配存储空间。适合表达编译
期已知且简单的固定值。

\begin{lstlisting}[language=C,caption={使用 \#define 定义宏常量},label={lst:define}]
#include <stdio.h>

#define PI 3.14       //经过指定后，本文件中所有PI都会被替换为3.14。
#define AREA(r) (PI * (r) * (r))      //定义函数宏，用于计算圆面积。

int main() {
    float r = 2.0;
    printf("Area = %.2f\n", AREA(r));
    return 0;
}       //简单理解：只是个文本替换而已。

\end{lstlisting}

在程序编译之前，预处理器会将代码中的
所有 \texttt{PI} 替换为3.14，所有 \texttt{AREA(r)}
 替换为(3.14 * (r) * (r))。

\item 常变量\texttt{const}  
   
\texttt{const}是 C 语言中的一个关键字，
表示“只读（只可读，不可改）”。
它可以用来修饰变量、指针、函数参数等，
使其在程序运行过程中不可被修改。

常变量具有类型信息，占用内存空间，只是其值
不可通过该标识符修改。适合表达接口常量、配置值等。

\begin{lstlisting}[language=C,caption={使用 const 定
  义常量变量},label={lst:const}]
#include <stdio.h>

const int   MAX_CONN = 1024;
const float PI       = 3.14159f;

int main(void) {
    MAX_CONN = 2048; //  编译报错：只读对象不可修改
    printf("%f\n", PI);
    return 0;
}
\end{lstlisting}

\newpage
要注意一件事情:修饰一个变量，只是使其在语义上为“只读”。


也就是说编译器虽然会禁止通过该常变量名字修改，但并
不保证存储区域物理上不可修改。\texttt{const} 变量
仍然占内存，只是不可通过其标识符修改。



\item \texttt{enum} 枚举常量

\texttt{enum} 定义一组自定义的\emph{整数常量}，
往往是一组有着共同特性的数据集合或是状态标签。这里
在展开讨论这一常量之前，先讲解一下枚举的概念。

\vspace{1em}%空出一行距离（当前字体高度）

\noindent\textbf{枚举}

枚举（Enumeration）是一种用户自定义的数据
类型，它由一组自定义标签的整数常量组成。每个枚举成员都
对应一个整数值（可以为负数），默认情况下，从 0 开始递增，也可以手动
指定起始值或各个具体值。枚举的主要目的是为了提高代码的可
读性和可维护性。

比如春夏秋冬这四个数据就是一组枚举数据，
它们可以用一个枚举类型来表示；再比如生活中的通讯录，就是
一个非常典型的枚举数据，如\autoref{fig:Contacts} 所示。

\vspace{1em}%空出一行距离（当前字体高度）
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\linewidth]{figures/通讯录.jpeg}
  \caption{生活中的枚举数据：通讯录}
  \label{fig:Contacts}
\end{figure}


电话号码11位数字，按道理来说，一共有 $10^{11}$ 种可能性，
但实际上，我们的通讯录中并不会存入这么多电话号码，
而是只会有其中离散的一部分，比如你亲人
、朋友、同事的号码。此时当我们需要拨打电话时，只能
从通讯录这几个离散的数据里面挑选。

\newpage

枚举的基本规则如\autoref{lst:enum basic}所示


\begin{lstlisting}[language=C,caption={使用 enum 基本规则},label={lst:enum basic}]
enum Color  { RED, GREEN, BLUE };        
// 数值若不自定义，则依次为 0,1,2
enum Weekday{ MON=1, TUE, WED, THU, FRI, SAT, SUN }; 
//若自定义了起始值，则后续依次递增1
enum State { ST_INIT=-5, ST_RUN=8, ST_ERR=9, ST_STOP=100 };
//也可自定义每个枚举值

//注意：枚举数据可以为负数，但必须为整数。
\end{lstlisting}

说完了基本规则，让我们来探讨一下枚举类型变量使用方法，
让我们通过一个示例来加深理解。

\begin{lstlisting}[language=C,caption={使用 enum 定义变量},label={lst:enum var}]
#include <stdio.h>

enum Color { RED, GREEN, BLUE }x;  // 定义枚举类型 Color 并声明变量 x


enum Weekday { MON, TUE, WED, THU, FRI, SAT, SUN };
enum Weekday this_month;  // 声明枚举类型 Weekday 变量 this_month
//这与上面Color的声明方式是等价的。

int main(void) {
    x = RED;  // 给枚举变量 x 赋值  //枚举变量的赋值只能在枚举成员中选择
    this_month = TUE;  // 给枚举变量 this_month 赋值
    printf("Color: %d, Weekday: %d\n", x, this_month);

    return 0;
}
\end{lstlisting}

在上面的示例中，我们定义了两个枚举类型，相信大家已经理解了枚举的
基本用法。接下来我们来接着探讨enum的常量特性。

\texttt{enum}常量是编译期符号，它不同于\texttt{const}常量，也不同于
\texttt{\#define}宏常量在预处理阶段就进行文本替换。
enum常量在编译期被替换为对应的整数值，
不占用任何内存空间，且只能表示整数类型。枚举变量一旦被声明之后
，其值只能在枚举成员中选择，不能赋予其他整数值。这一安全特性使得
枚举常量非常适合表示离散的状态或类别，可以有效提高代码的安全性和可读性。

\end{enumerate}





























\noindent%取消首行缩进
\subsection{命名规则与规范}
\subsubsection{命名规则}
对于字符的组成，变量和常量遵循相同的规则。变量名只能由字母、数字和下划线组成，且首字符不能为
    数字（虽然语法上允许首字符为 \_ ，但在实际编程和标准库约定中有一些潜在风险）
\begin{itemize}
    \item 区分大小写，如 \texttt{age} 与 \texttt{Age} 是不同变量；
    \item 不得与关键字（\texttt{int}, \texttt{return} 等）同名；
\end{itemize}
\subsubsection{代码命名规范}

\begin{enumerate}[label={（\arabic*）}] % 括号编号，使用中文括号编号
  \item 变量命名规范：变量命名通常使用小写字母和下划
  线(例如 \texttt{total\_count})，或者在某些语言中使用驼峰
  式命名。（例如\texttt{totalCount} ）
  \item 常量命名规范:
  常量通常采用全大写字母，单词之间用下划线分
  隔。这是为了让开发者在看到常量时，能够立刻
  识别它们是固定值，而不是可变的数据。
  例如：\texttt{MAX\_SIZE}、\texttt{PI}、\texttt{BUFFER\_LIMIT}。  
\end{enumerate}


  这种约定使得代码更加一致，并且提高了可读性和维护性。


\vspace{1em}%空出一行距离（当前字体高度）
\noindent
\subsection{作用域与生命周期}

\subsubsection{变量}

\begin{enumerate}[label={（\arabic*）}] % 括号编号，使用中文括号编号
  \item 局部变量：定义在函数或语句块中，仅在该范围内有效。每次进入函数时该变量都会被
    重新创建并初始化，生命周期仅限于函数调用期间。当函数或语句块执
    行结束后，变量随即被销毁，内存空间被回收；
  \item 全局变量：定义在所有函数外部，全文件范围内可访问。其生命周
    期从程序开始运行到程序结束，在此期间始终占据固定的内存空间。
    全局变量可被同一文件内的所有函数访问（若需跨文件访问，可使用 extern 声明）。
  \item 静态变量（\texttt{static}）：使用关键字 static 声明。
它的作用域视其属于局部变量还是全局变量而定，但其生命周期贯穿整个程序执行过程。


也就是说，即使该变量为在函数或语句块中定义的局部变量，其在函数调用结束后也不会被销毁，而是保留其上一次的值；
下次进入函数时会继续使用原来的值，而不是重新初始化。
\end{enumerate}


\vspace{1em}%空出一行距离（当前字体高度）
\vspace{1em}%空出一行距离（当前字体高度）
\noindent%取消首行缩进
\textbf{示例}
\begin{lstlisting}[language=C,caption={局部变量与静态局部变量示例},label={lst:foo_static}]
void foo() {
    int x = 0;           // 局部变量
    static int y = 0;    // 静态局部变量
    x++;
    y++;
    printf("x=%d, y=%d\n", x, y);
}
\end{lstlisting}

\vspace{1em}%空出一行距离（当前字体高度）
\vspace{1em}%空出一行距离（当前字体高度）
\vspace{1em}%空出一行距离（当前字体高度）

\noindent
连续调用 \texttt{foo()} 三次的输出为：

\begin{verbatim}
                              x=1, y=1
                              x=1, y=2
                              x=1, y=3
\end{verbatim}



由于局部变量在函数调用时被创建，并在函数结束后自动销毁，因此每次进
入函数时，x 都会重新初始化为 1。而静态局部变量 y 的生命周期贯穿整个
程序运行过程，因此它的值在每次函数调用后都会保留并继续增加。


\subsubsection{常量}

\begin{enumerate}[label={（\arabic*）}] % 括号编号，使用中文括号编号
  \item 局部常量：当常量在函数内部使用 \texttt{const} 声
  明时，它的作用域仅限于该函数或代码块。这样的常量在函数调用结束后被销毁；
  \item 全局常量：当常量在函数内部使用 const 声
  明时，它的作用域仅限于该函数或代码块。这样的常量在函数调用结束后被销毁。
    全局变量可被同一文件内的所有函数访问（若需跨文件访问，可使用 extern 声明）。
  \item 静态常量（\texttt{static}）：与前面静态变量相似，如果常量声明为 static，它
  的生命周期会贯穿整个程序运行期间，即使它的作用域限于声明的文件或函数。
\end{enumerate}







\newpage

\subsection{数据类型}


为什么在计算机运算时要指定数据的类型呢？
在数学中，数值是不分类型的，数值的
运算是绝对准确的，例如：78与97之和为175，
1/3的值是0.33333333……（循环小数）。数学是
一门研究抽象问题的学科，数和数的运算都是抽象
的。

而在计算机中，数据是存放在存储单元中的，
它是具体存在的。而且，存储单元是由有限的字节
构成的，每一个存储单元中
存放数据的范围是有限的，不可能存放“无穷大”的数，
也不能存放循环小数。

例如用C程序计算和输出1/3：
程序printf("\%f" , 1.0/3.0);
得到的结果是0.333333， 只能得到6位小数，而不是
无穷位的小数。

因此，在计算机中，数据必须有类型，
不同类型的数据在存储单元中所占的字节数不同，
表示的数据范围也不同，数据的运算规则也不同。
在展开讨论C语言的数据类型之前，我们先深入了解
一下整数与浮点数的存储原理。

\subsubsection{整数的存储与表示}

加法和减法是计算机中最基本的运算，计算机
时时刻刻都离不开它们，所以它们由硬件直接支持。
与此同时，早期计算机电路为了提高加减法的运算效率，
硬件电路需要设计得尽量简单，可是这样一来减法电路
就势必要被阉割掉，因为减法电路的设计要比加法复杂得多。
因此困扰早期计算机设计者的一个重要问题开始浮现：

\vspace{1em}%空出一行距离（当前字体高度）

\indent\textbf{如何用加法电路来实现减法运算？}

\vspace{1em}%空出一行距离（当前字体高度）

要想要实现减法效果，实际上就是在思考怎样才能得到数字0。如果说
a+b=0，那么b就等于-a。此时的b也就是我们想要的减法效果
。显然，从纯数学的角度来说，这个问题是无解的，因为不可能
有两个正数相加等于0。但是不要忘了这里不是纯粹的数学世界，我们发现计算机的
物理电路还有一个重要的特性：\textbf{加法器的自然进位溢出}。
换而言之，我们可以通过一直加，直到数字溢出回到0，从而实现
减法的效果。

\vspace{1em}%空出一行距离（当前字体高度）
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.4\linewidth]{figures/加法器.png}
  \caption{加法器}
  \label{fig:Adder}
\end{figure}

\newpage


这就好比一个时钟，如\autoref{fig:Clock}所示，时钟的时针此时
指向5点钟，如果我们想让这个时钟归0（也就是指向12点钟）。那么
一共有两种办法，一种是逆时针转动5个小时（这其实就是对应了负数），
另一种是顺时针转动7个小时（而这就是加法溢出）。





\vspace{1em}%空出一行距离（当前字体高度）
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.4\linewidth]{figures/时钟.png}
  \caption{时钟}
  \label{fig:Clock}
\end{figure}

\indent\textbf{原码反码补码}

\vspace{1em}%空出一行距离（当前字体高度）

了解完以上原理，我们就可以引出整数的存储表示方法了。
在计算机中，整数使用\textbf{补码}来表示。补码的
出现，彻底解决了计算机中加减法运算的问题。从此
计算机不再关注数字的正负，而只需要关注数字的二进制位
即可。这样一来，计算机的加法器就可以直接进行加减法运算。


\begin{enumerate}[label=\ding{\numexpr171+\arabic*}] % 括号编号，使用中文括号编号
  \item 原码：最高位为符号位，0表示正数，1表示负数。其余位表示数值的大小。
  \item 反码：正数的反码与原码相同，负数的反码是将原码中除符号位外，其他位取反。
  \item 补码：正数的补码与原码相同，负数的补码是将反码加1。
\end{enumerate}

\vspace{1em}%空出一行距离（当前字体高度）
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.4\linewidth]{figures/原码反码补码.jpg}
  \caption{原码、反码与补码的表示}
  \label{fig:complement}

\end{figure}


\newpage




\newpage



C语言的数据类型系统为所有数据（无论变量或常量）提供
统一的分类标准，包括：


\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\linewidth]{figures/C语言数据类型.jpeg}
  \caption{C语言数据类型（典型字节数）}
  \label{fig:nature}
\end{figure}










\newpage


