# 第 3 章 数据类型

## 3.1 为什么需要数据类型？
- 数据类型的本质：对内存中比特模式的一种解释
- 为什么计算机不能进行无限精度的数学运算
- 类型影响：存储格式 + 运算规则
- 有限位宽带来的问题：溢出、截断、精度损失

---

## 3.2 整数的存储：原码、反码与补码

### 3.2.1 负数为什么需要特殊表示？
- 加减法共享同一加法器
- 原码的问题
- 反码、补码的历史意义

### 3.2.2 二补码完整介绍
- 正数、负数、0 的补码
- 反码与补码的转换
- 补码如何支持加法器溢出回绕

### 3.2.3 示例：补码构造过程

### 3.2.4 补码即模 2ⁿ 算法
- 有符号整数范围
- 回绕的数学意义

---

## 3.3 C23 标准中的整数

### 3.3.1 C23 强制使用补码
- C89/C99/C11 的历史遗留
- 补码的硬件决定论
- C23 做出的变更

### 3.3.2 有符号溢出是未定义行为（UB）
- 为什么会 UB
- 示例与风险

### 3.3.3 无符号溢出是模 2ⁿ
- 数学意义的循环

---

## 3.4 整型大小与平台模型（ILP32 / LP64 / LLP64）
- 为什么整型大小不是固定的
- 常见平台模型表
- 如何写跨平台代码：stdint.h、size_t、ptrdiff_t

---

## 3.5 字节序（Endianness）
- 大端与小端
- 内存示例
- 字节序在通信协议中的意义

---

## 3.6 整数提升与通常算术转换

### 3.6.1 整数提升（integer promotion）
- char/short → int
- 常见错误示例

### 3.6.2 通常算术转换（usual arithmetic conversions）
- signed vs unsigned
- 混合运算规则

---

## 3.7 浮点数（IEEE 754）

### 3.7.1 存储格式
- 符号、阶码、尾数

### 3.7.2 浮点误差来源
- 0.1 不可表示
- 比较方法：epsilon

### 3.7.3 float/double/long double 差异

---

## 3.8 字符类型
- char 是整数类型
- signed/unsigned char 的平台差异
- ASCII vs UTF-8

---

## 3.9 布尔类型
- _Bool 与 stdbool.h
- true/false 与 0/1

---

## 3.10 C 语言数据类型总览（现代版）
- 整数
- 浮点
- 字符
- 布尔
- 固定宽度整数（stdint.h）

---

## 3.11 数据类型常见踩坑（工程实践）
- signed + unsigned 的问题
- 整数提升导致的溢出
- sizeof 的平台差异
- printf 格式符错误
- 浮点精度问题
- 字节序 bug
- UB 导致的 O2 优化异常

---

## 3.12 小结
- 数据类型的本质
- C23 的变化
- 如何在工程中正确使用类型
